from contractda.sets import ClauseSet, FOLClauseSet
from contractda.vars._var import IntVar, BoolVar, RealVar, CategoricalVar

if __name__ == "__main__":

    x = RealVar("x")
    y = RealVar("y")
    z = RealVar("z")
    a = BoolVar("a")
    clause = FOLClauseSet(vars=[x, y, z],expr="x + y == 4 && 2*x + 5 == 4")
    assert(clause.is_satifiable())
    clause = FOLClauseSet(vars=[x, y, z],expr="x + y == 1 || x + y == 10")
    assert(clause.is_satifiable())
    clause = FOLClauseSet(vars=[x, y, z],expr="x + y == 1 && x + y == 10")
    assert(not clause.is_satifiable())
    clause = FOLClauseSet(vars=[x, y, z],expr="x + y == y && x ^ 4 == 10")
    assert(not clause.is_satifiable())
    clause = FOLClauseSet(vars=[x, y, z],expr="(x + y) ^ 2 == 4 && x == 2")
    assert(clause.is_satifiable())
    clause = FOLClauseSet(vars=[x, y, z],expr="(x + y + z) ^ 3 == 8 && x == 2 && y != 3")
    assert(clause.is_satifiable())
    # clause = FOLClauseSet(vars=[a, x, y, z],expr="(a == false) && (x + y + z) ^ 3 == 8 && x == 2 && y != 3")
    # assert(clause.is_satifiable())
    clause = FOLClauseSet(vars=[a, x, y, z],expr="(a == true) && (x + y + z) ^ 3 == 8 && x == 2 && y != 3")
    assert(clause.is_satifiable())
    clause = FOLClauseSet(vars=[a, x, y, z],expr="!a && (x + y + z) ^ 3 == 8 && x == 2 && y != 3")
    assert(clause.is_satifiable())

    clause1 = FOLClauseSet(vars=[x, y],expr="x + y == 4 && 2*x + 5 == 4")
    clause2 = FOLClauseSet(vars=[a, y, z],expr="(a == true) && (y + z) ^ 3 == 8 && y != 3")
    ret = clause1.union(clause2)
    print(ret.expr.root, ret._vars)
    print(ret.is_satifiable())
    print("")
    ret = clause1.intersect(clause2)
    print(ret.expr.root, ret._vars)
    print(ret.is_satifiable())
    print("")
    ret = clause1.difference(clause2)
    print(ret.expr.root, ret._vars)
    print(ret.is_satifiable())

    print("")
    ret = clause1.complement()
    print(ret.expr.root, ret._vars)
    print(ret.is_satifiable())